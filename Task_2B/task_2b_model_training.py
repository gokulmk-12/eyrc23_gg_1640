# -*- coding: utf-8 -*-
"""base_model_8_hidden.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QAqqxbHd_YetFRP67LZ4OCblDSZ0CTNi
"""

import os
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import transforms, models
from torch.utils.data import DataLoader
from torch.autograd import Variable
from PIL import Image
import matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from torchvision.datasets import ImageFolder
import numpy as np

device="cuda" if torch.cuda.is_available() else "cpu"
device

data_transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(90),
    transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2, hue=0.2),
    transforms.RandomGrayscale(p=0.4),
    transforms.RandomRotation(270),
    transforms.ToTensor()
])
test_transform=transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor()
])

class CustomDataset(Dataset):
    def __init__(self, data_dir, transform=None):
        self.data = ImageFolder(root=data_dir, transform=transform)
        self.classes = self.data.classes

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        image, label = self.data[idx]
        return image, label

train_data_dir = '/home/rishwanth/EYRC/Task_2B/Task_2B_files/train'
test_data_dir = '/home/rishwanth/EYRC/Task_2B/Task_2B_files/test'

train_dataset = CustomDataset(train_data_dir, transform=data_transform)
test_dataset=CustomDataset(test_data_dir,transform=test_transform)
class_names = train_dataset.classes

for label, class_name in enumerate(class_names):
    print(f"Class Label {label}: {class_name}")

print((train_dataset[0][0]))

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=1, shuffle=True)

model = models.resnet18(pretrained=True)



num_classes = len(train_dataset)
print(num_classes)


model.fc = nn.Linear(512, num_classes)
additional_layers = nn.Sequential(
     nn.Linear(num_classes, 128),
     nn.Dropout(0.5),
     nn.Linear(128,64)

)


class CustomResNet(nn.Module):
    def __init__(self, original_model,additional_layers):
        super(CustomResNet, self).__init__()
        self.features = original_model
        self.add_layers = additional_layers

    def forward(self, x):
        x = self.features(x)
        x = x.view(x.size(0), -1)
        x = self.add_layers(x)
        return x


model = CustomResNet(model,additional_layers)

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
model = model.to(device)

criterion = nn.CrossEntropyLoss()
optimizer =optim.SGD(model.parameters(), lr=0.0065,momentum=0.01)

train_losses = []
test_losses = []
train_accuracies = []
test_accuracies = []


num_epochs = 15

for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0
    correct = 0
    total = 0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)

        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

    train_loss = running_loss / len(train_loader)
    train_accuracy = 100 * correct / total


    model.eval()
    test_loss = 0.0
    correct = 0
    total = 0
    with torch.no_grad():
        for inputs, labels in test_loader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            test_loss += loss.item()
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    test_loss = test_loss / len(test_loader)
    test_accuracy = 100 * correct / total

    print(f'Epoch {epoch + 1}, Training Loss: {train_loss:.4f}, Training Accuracy: {train_accuracy:.2f}%, Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.2f}%')


    train_losses.append(train_loss)
    test_losses.append(test_loss)
    train_accuracies.append(train_accuracy)
    test_accuracies.append(test_accuracy)



torch.save(model.state_dict(), 'GG_1640_FINAL.pth')

train_losses= np.array(train_losses)
test_losses= np.array(test_losses)
train_accuracies= np.array(train_accuracies)
test_accuracies= np.array(test_accuracies)

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(train_losses, label='Training Loss', marker='o')
plt.plot(train_accuracies, label='Training Accuracy', marker='o')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training and Testing Loss Over Epochs')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(test_losses, label='Testing Losses', marker='o')
plt.plot(test_accuracies, label='Testing Accuracy', marker='o')
plt.xlabel('Epoch')
plt.ylabel('Accuracy (%)')
plt.title('Training and Testing Accuracy Over Epochs')
plt.legend()

plt.tight_layout()
plt.show()



































